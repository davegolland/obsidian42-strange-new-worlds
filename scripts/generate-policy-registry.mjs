// scripts/generate-policy-registry.mjs
import fs from "fs";
import path from "path";
import url from "url";

const __filename = url.fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT = path.resolve(__dirname, "..");
const POLICIES_DIR = path.join(ROOT, "src", "policies", "policies");
const OUT_FILE = path.join(ROOT, "src", "policies", "auto-registry.ts");
const TYPES_FILE = path.join(ROOT, "src", "policies", "auto-types.ts");

// Convert "CaseInsensitivePolicy.ts" -> { id: "case-insensitive", className: "CaseInsensitivePolicy" }
function fileToIdAndClass(filePath) {
  const base = path.basename(filePath, ".ts");
  const id = base
    .replace(/Policy$/, "")            // drop trailing "Policy"
    .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
    .toLowerCase();
  const content = fs.readFileSync(filePath, "utf8");

  // Try to find the exported class name
  const m = content.match(/export\s+class\s+([A-Za-z0-9_]+)/);
  if (!m) {
    throw new Error(`Could not find "export class" in ${filePath}. Ensure the policy class is exported.`);
  }
  const className = m[1];
  
  // Check if this policy needs constructor parameters
  const needsConstructorParams = content.includes("constructor(") && 
    !content.includes("constructor()") && 
    !content.includes("constructor() {");
  
  return { id, className, needsConstructorParams };
}

function main() {
  const entries = fs.readdirSync(POLICIES_DIR)
    .filter(f => f.endsWith(".ts"))
    .map(f => path.join(POLICIES_DIR, f));

  const items = entries.map(full => {
    const { id, className, needsConstructorParams } = fileToIdAndClass(full);
    const relImport = "./policies/" + path.basename(full, ".ts"); // Keep .ts extension for TypeScript
    return { id, className, relImport, needsConstructorParams };
  });

  const header = `/* AUTO-GENERATED FILE. DO NOT EDIT.
   * Generated by scripts/generate-policy-registry.mjs
   */
`;
  const imports = items
    .map((it, i) => `import { ${it.className} } from "${it.relImport}";`)
    .join("\n");

  const body = `
import { _registerPolicy } from "./registry";

// Instantiate and register each discovered policy
${items.map(it => {
  if (it.needsConstructorParams) {
    // Skip policies that need constructor parameters for now
    return `// _registerPolicy("${it.id}", new ${it.className}({ endpoint: "http://localhost:8787/iw/key", apiKey: "env:IW_KEY" })); // TODO: Configure external service policy`;
  } else {
    return `_registerPolicy("${it.id}", new ${it.className}());`;
  }
}).join("\n")}
`;

  fs.writeFileSync(OUT_FILE, header + imports + body, "utf8");
  
  // Generate types file
  const typesHeader = `/* AUTO-GENERATED FILE. DO NOT EDIT.
   * Generated by scripts/generate-policy-registry.mjs
   */
`;
  const policyIds = items.map(it => it.id);
  const typesContent = `${typesHeader}
export type WikilinkEquivalencePolicyType = ${policyIds.map(id => `"${id}"`).join(" | ")};
`;

  fs.writeFileSync(TYPES_FILE, typesContent, "utf8");
  
  console.log(`[policy-registry] Wrote ${path.relative(ROOT, OUT_FILE)} with ${items.length} policies.`);
  console.log(`[policy-registry] Wrote ${path.relative(ROOT, TYPES_FILE)} with ${items.length} policy types.`);
}

main();
